# TODO: Улучшения надежности и производительности

## 2. Конфигурация кэширования

### 2.1. Файл с константами TTL

**Зачем нужно:**

- Убрать магические числа из кода
- Централизованное управление временем жизни кэша
- Легкая настройка для разных окружений

**Что нужно сделать:**

#### Создать файл конфигурации

- Файл: `src/config/cacheConfig.ts`
- Экспортировать объект с TTL для каждого типа данных:
  ```typescript
  export const CACHE_TTL = {
  	TAGS: {
  		LIST: 5 * 60 * 1000, // 5 минут
  		ITEM: 10 * 60 * 1000, // 10 минут
  	},
  	BLOCKS: {
  		LIST: 1 * 60 * 1000, // 1 минута
  		TREE: 1 * 60 * 1000, // 1 минута
  		ITEM: 5 * 60 * 1000, // 5 минут
  	},
  	SOURCES: {
  		LIST: 5 * 60 * 1000, // 5 минут
  		ITEM: 10 * 60 * 1000, // 10 минут
  		ACTIVITY: 30 * 1000, // 30 секунд
  	},
  	VALUES: {
  		VALUES: 30 * 1000, // 30 секунд
  		STATUS: 10 * 1000, // 10 секунд
  	},
  	USERS: {
  		LIST: 5 * 60 * 1000, // 5 минут
  		ITEM: 10 * 60 * 1000, // 10 минут
  	},
  	USER_GROUPS: {
  		LIST: 5 * 60 * 1000, // 5 минут
  		TREE: 5 * 60 * 1000, // 5 минут
  		ITEM: 10 * 60 * 1000, // 10 минут
  	},
  } as const
  ```

#### Обновить stores

- Заменить все хардкоженные TTL значения на константы из `cacheConfig.ts`
- Файлы для обновления:
  - `TagsStore.ts`
  - `BlocksStore.ts`
  - `SourcesStore.ts`
  - `ValuesStore.ts`
  - `UsersStore.ts`
  - `UserGroupsStore.ts`

#### Опционально: конфигурация через env

- Добавить возможность переопределения TTL через переменные окружения
- Для dev/prod окружений можно использовать разные значения

---

## 3. Lazy loading компонентов

### 3.1. Code splitting без деградации UI

**Зачем нужно:**

- Уменьшение размера начального бандла
- Ускорение первой загрузки приложения
- Улучшение производительности

**Что нужно сделать:**

#### Настроить lazy loading для страниц

- Файл: `src/app/router/appRouter.tsx`
- Обернуть импорты страниц в `React.lazy()`
- Пример:
  ```typescript
  const TagsList = lazy(() => import('./pages/tags/TagsList'))
  const BlocksTree = lazy(() => import('./pages/blocks/BlocksTree'))
  // и т.д.
  ```

#### Добавить Suspense с fallback

- Обернуть роуты в `<Suspense>` с красивым fallback
- Использовать существующий компонент загрузки или создать новый
- Файл: `src/app/router/AppLayout.tsx` или создать обертку

#### Оптимизировать fallback

- Создать компонент `LoadingFallback.tsx`
- Показывать скелетон или спиннер, соответствующий дизайну
- Убедиться, что fallback не вызывает деградацию UX

#### Предзагрузка критичных страниц

- Для часто используемых страниц можно добавить prefetch
- Использовать `link rel="prefetch"` или программную предзагрузку

#### Проверить работу

- Убедиться, что переходы между страницами плавные
- Нет мерцания при загрузке
- Fallback отображается корректно

---

## 4. Retry при получении определенных ошибок

### 4.1. Retry механизм для 503 и других ошибок

**Зачем нужно:**

- Обработка временных сбоев сервера
- Поддержка Retry-After заголовка (503 Service Unavailable)
- Улучшение надежности при нестабильном соединении

**Что нужно сделать:**

#### Создать утилиту для retry

- Файл: `src/utils/retry.ts`
- Функция `retryWithBackoff<T>(fn, options)`
- Параметры:
  - `maxRetries: number` - максимальное количество попыток
  - `initialDelay: number` - начальная задержка (мс)
  - `maxDelay: number` - максимальная задержка (мс)
  - `backoffMultiplier: number` - множитель для экспоненциального backoff
  - `retryCondition: (error) => boolean` - условие для retry
  - `onRetry?: (attempt, error) => void` - callback при retry

#### Обработка Retry-After заголовка

- Функция `parseRetryAfter(header: string): number`
- Парсить значение из заголовка `Retry-After` (может быть секунды или дата)
- Использовать это значение как задержку перед следующей попыткой

#### Интегрировать в API interceptor

- Файл: `src/store/appStore.ts`
- В `createApiClient()` добавить retry логику в response interceptor
- Обрабатывать ошибки:
  - `503 Service Unavailable` - retry с учетом Retry-After
  - `502 Bad Gateway` - retry с экспоненциальным backoff
  - `504 Gateway Timeout` - retry с экспоненциальным backoff
  - `429 Too Many Requests` - retry с учетом Retry-After
- Не retry для:
  - `401 Unauthorized`
  - `403 Forbidden`
  - `400 Bad Request`
  - `404 Not Found`

#### Настройки retry

- Файл: `src/config/retryConfig.ts`
- Константы:
  ```typescript
  export const RETRY_CONFIG = {
  	MAX_RETRIES: 3,
  	INITIAL_DELAY: 1000, // 1 секунда
  	MAX_DELAY: 30000, // 30 секунд
  	BACKOFF_MULTIPLIER: 2,
  	RETRYABLE_STATUS_CODES: [502, 503, 504, 429],
  } as const
  ```

#### Логирование retry попыток

- Логировать каждую попытку через logger
- Показывать пользователю индикатор при retry (опционально)
- Не показывать ошибку до исчерпания всех попыток

#### Интегрировать в stores

- В методах загрузки данных (`loadTags`, `loadBlocks`, etc.) использовать retry
- Или обрабатывать на уровне API interceptor (предпочтительнее)

---

## Порядок выполнения

1. **Обработка ошибок** (2-3 дня)
   - Создать Error Boundary
   - Создать logger сервис
   - Заменить console.\* на logger
   - Исправить AppError.tsx

2. **Конфигурация кэширования** (1 день)
   - Создать cacheConfig.ts
   - Обновить все stores

3. **Lazy loading** (1-2 дня)
   - Настроить lazy loading для страниц
   - Добавить Suspense с fallback
   - Протестировать UX

4. **Retry механизм** (2-3 дня)
   - Создать retry утилиту
   - Интегрировать в API interceptor
   - Протестировать различные сценарии ошибок

---

## Критерии готовности

- ✅ Error Boundary защищает приложение от падений
- ✅ Все ошибки логируются через централизованный logger
- ✅ Нет console.\* в продакшене
- ✅ TTL значения вынесены в конфигурацию
- ✅ Страницы загружаются через lazy loading
- ✅ Нет деградации UI при lazy loading
- ✅ Retry работает для 503 и других временных ошибок
- ✅ Retry-After заголовок обрабатывается корректно
- ✅ Пользователь видит понятные сообщения об ошибках

---

## Примечания

- При реализации Error Boundary важно не перехватывать ошибки, которые должны всплывать (например, ошибки валидации форм)
- Retry должен быть умным - не retry для ошибок, которые точно не исправятся повторным запросом
- Lazy loading должен быть прозрачным для пользователя - переходы должны быть плавными
- Конфигурация кэширования может быть расширена для разных окружений (dev/staging/prod)
