using DatalakeDb.Enums;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace DatalakeDb.Models
{
	/*
	 * Тег это переменная для обозначения серии данных, отображающих одно значение
	 * 
	 * Тег должен быть уникальным для базы.
	 * Должен ли тег быть уникальным для распределенной сети? Нужен способ найти, где он используется, поэтому логично обозначать теги уникальными ключами
	 * 
	 * Тег использует в качестве источника данных какой-то поставщик, и им может быть другой тег.
	 * В тегах хранятся примитивы - строки, числа, булеаны.
	 * 
	 * Есть автоматические и мануальные теги. Мануальные не имеют источника и получают значения через функцию записи в API.
	 * 
	 * Логика обновления автоматического тега - мы или опрашиваем источник с какой-то периодичностью, или ждем сигнала о появлении нового значения. Если источник не знает, какие теги его используют, то вариант с сигналами отпадает? Нет, если подписываться на сигнал источника по аналогии с websocket. Вариант с опросом вроде проще, но для производительности сигналы по идее будут лучше.
	 * 
	 * У некоторых типов есть уникальная логика. Возможно её настройку лучше выделить в отдельную таблицу через связь один к одному
	 * 
	 * Для числовых тегов появляется возможность изменения значения по другой шкале через тождества min-max исходной и конечной шкал
	 * 
	 * Для булевых тегов можно задать подписи на true и false значения, чтобы придать им читабельность
	 * Возможно, стоит сделать числовые теги с похожей функцией? Пока не нужно
	 * 
	 * Кроме естественных источников данных, есть и искусственные - система и модуль вычисления
	 * 
	 * Система записывает данные в процессе работы в группу тегов, помечаемых как системные
	 * 
	 * Модуль вычисления использует формулы библиотеки NCalc, чтобы получать новое значение на основе других значений
	 */
	public class Tag
	{
		[Key, DatabaseGenerated(DatabaseGeneratedOption.Identity)]
		public uint Id { get; set; }

		public Guid GlobalId { get; set; } = Guid.Empty;

		public string Name { get; set; } = string.Empty;

		public string Description { get; set; } = string.Empty;

		public TagType Type { get; set; }

		// числовые

		public bool IsScaling { get; set; } = false;

		public float MinEU { get; set; } = float.MinValue;

		public float MaxEU { get; set; } = float.MaxValue;

		public float MinRaw { get; set; } = float.MinValue;

		public float MaxRaw { get; set; } = float.MaxValue;

		// вычисляемые

		public bool IsCalculating { get; set; } = false;

		public string Formula { get; set; } = string.Empty;
	}
}
